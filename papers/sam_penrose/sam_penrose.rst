:author: Sam Penrose
:email: spenrose@mozilla.com
:institution: Mozilla Corporation, 331 E Evelyn Ave, Mountain View, CA 94041

----------------------------------------------------------------
Towards Explicit Models for the Practice of Computer Programming
----------------------------------------------------------------

.. class:: abstract

   For half a century we have developed software with our hands and eyes, alternately making and reading small changes to our output and relying on the procedural homology between writing and executing software. This skill ("EROL coding") is normally acquired by trial-and-error and informal cultural transmission. Code meant to run remotely in parallel on large inputs ("Distributed Computing at Scale" or "DCS coding") cannot be effectively developed using EROL techniques.

  Examination of the working practices of one DCS community reveals that DCS coding has a complex but legible structure. We provide a model for the procedural structure of DCS coding which can be evaluated both for accuracy of fit and value as a tool for transmitting knowledge.

.. class:: keywords

   big data, distributed computing, programming, deliberate practice

Introduction
------------

Digital computers are defined by their capacity to calculate numbers by following a series of instructions [TUR1936]_. They are defined *procedurally*.  Within 6 years of the definition of the dominant electronic computer architecture [VON1945], the procedures a human should follow to define the procedures her computer should follow were documented:

  Experience has shown that [it is] rare for a program to work correctly the first time it is [run], and often several [iterations] must be made before all errors are eliminated. ... Location of mistakes in a program ... One simple and very useful plan is to place a [print statement] ... in front of each subroutine. :cite:`WIL1951`

From the beginning, formal publication was the exception and informal transmission the dominant mode of training in the procedures of programming:

    "I don't think that any [of us] stopped talking the whole time," Hopper recalled ... The dearth of computing publications was a poor indication of the amount of knowledge already generated by the evolving community of practice. Instead of being physically located in books and journal articles, knowledge resided in the minds of the pioneers. :cite:`BEY2011`

Eventually, EROL was described in somewhat more detail:

  [P]rogrammers ... spend as much time debugging as writing ... It's usually easy to find out where the program was executing when it died, examine the sequence of functions that were active (the *stack trace*), and display the values of local and global variables. That much information may be sufficient to identify a bug. ... Fortunately, most bugs are simple and can be found with simple techniques. Examine the ... erroneous output [or] stack trace ... Now you know something of what happened, and where. Pause to reflect. How could that happen? ... Once we have a full explanation, we'll know what to fix. :cite:`KR1999`

Note the conclusion: once we fully understand the states which the program occupied, we understand how to fix them. To identify the problem is to identify the solution. There are no extra procedures necessary for navigating from the former to the latter.

Publications on the practice of programming today fall into two broad categories:

  1) Peer advice derived from experience and informal communication.
  2) Peer-reviewed analysis derived from small-scale studies.

The former engages programmers as subjects and can be quite valuable and popular in practice, but proceeds informally [#]_. The second does not define the practice of programming in the way that the "Methods" sections of peer-reviewed papers materially (if partially) define the practice of their fields. The heart of traditional programming is this tiny procedure:

   1) Edit your procedural instructions to the computer.
   2) Run the program.
   3) Observe the state of program as affected by your edit.
   4) Loop back to step 1.

Call it "EROL".

.. [#] [MCC2004]_ and [FOW1999]_ are counter-examples of peer advice which provides explicit procedural structure, some of which has migrated into machines (e.g. the technique Fowler identifies as "Rename Method" is a command in some IDEs). But they are exceptions.

Procedural homology
-------------------
Digital computing was defined by Alan Turing's effort to define the procedures of computation for a machine. Exploiting *procedural homology* has proven fundamental to progress in making digital computers. Grace Hopper invented the compiler by converting to computer code the procedures she followed when encoding her calculations:

    There sat that beautiful big machine whose sole job was to copy things and do addition. Why not make the computer do [those micro-procedures of programming] ? That’s why I sat down and wrote the first compiler. … What I did was watch myself put together a program and make the computer do what I did. :cite:`HOP1980`

Note that there are multiple procedural homologies here. Hopper describes the process of invention as observing her established human procedures, then creating computer "procedures" (in both the technical and common senses) which mirrored them.

Just a decade after Hopper's compiler, the Lisp REPL [MCC1962]_ was a third immediately-recognized breakthrough in computation which relied on procedural homology. REPL stands for "Read, Evaluate, Print, Loop". The parallel with its human operator's procedures is exact and effective, because they are two halves of a dialogue that forms a "loop":

  Human    | Lisp Interpreter
  -------- | -----------
  Edit     -> Read
    ^          |
    |          v
    | ("Run"/) Eval
    |          |
    |          v
  Observe  <- Print



Distributed Computing at Scale
------------------------------
DCS breaks observation. Procedural computing was invented to demonstrate the calculation of chosen "numbers" [1936TUR] and spread in contexts were the domain of variables was defined in advance. DCS breaks through the procedural programming frame's reliance on observability in two ways. First, scale by itself prevents us from observing program state: no human can scan 10^9 values. Second, much DCS exists to cope with exogenous inputs, whether from sensors in the scientific world or millions of user agents in the business world. Not only can those external generators not be relied on to produce values within a domain we have chosen: quantifying the domain they have chosen is often an important goal of DCS projects.

Constraining Procedurality
Inspired by functional programming, Google adopted and popularized the "Map-Reduce" approach to DCS. Map-Reduce frameworks orchestrate the distribution of code and data, asking users to define only two procedures conforming to a specific API. Map-Reduce does not fit all problem domains well [SLF2013]_. Worse, it does nothing to address the conflict between the potentially enormous variance presented by exogenously generated data and EROL coding.

Declarative programming, especially SQL, is a popular model for DCS [SPA2015]_. The programmer expresses what their *ends* in a structured language and a query engine compiles those ends into procedures—means—for execution. Declarative programming is extremely effective for dealing with scale per se, but it requires the exogenous elimination of variance. Before it can run your SQL expression, the engine must be given a "table": data whose structure and domain of values is defined in advance. Missing or out-of-domain values are often converted to NULL, a pseudo-value whose evaluation has second-order effects on computations. More generally, declarative programming was designed for static and structurally defined stocks, while DCS often must cope with exogenously-varying flows [DAV2012]_. The behavior of computating systems is by definition value-dependent [TUR1936]_, but declarative approaches move the procedural choices from what the programmer writes to what an engine invisibly generates.

Modeling DCS Programming
------------------------
DCS state from the programmer's perspective
In the EROL model, the programmer observes *program* state. In DCS, the programmer can only observe *messages* from the program. Observations comprise three types:

.. table:: DCS messages and meanings :label:`dcsmmtable`

   +-----------------+-----------------+
   | Message type    | Meaning         |
   |=================+=================+
   | A return value  | Code worked     |
   | An error report | Crash           |
   | Silence         | Working or crash|
   +-----------------+-----------------+

Error reports always indicate a problem from the perspective of the programmer. The others may or may not.

.. table:: DCS messages to Problems :label:`dcsmptable`

   +-----------------+---------------------------+
   | Message type    | Problem                   |
   |=================+===========================+
   | Return value    | Prior belief violated     |
   | Crash (my code) | Conflict: my code vs data |
   | Crash (system)  | Overload of system        |
   | Silence         | Slow or Overload or Dead  |
   +-----------------+---------------------------+

Problems in turn can be consistently mapped to root causes:

.. table:: DCS Problems to Causes :label:`dcspctable`

   +-----------------+----------------------------+
   | Problem  | Root cause(s)                     |
   |=================+============================+
   | Prior    | Bad mental model of code <-> data |
   | Conflict | Data Variance                     |
   | Overload | Allocation or Load                |
   | Slow     | Allocation or Load                |
   | Dead     | Allocation or Load                |
   +----------+-----------------------------------+

DCS Techniques
A DCS community [MOZ2017] relies on both traditional and novel techniques:

1) Parsing error reports.
2) Localizing data sample.
3) Reducing the ratio of data / computing resources.

A model for DCS programming
Procedural programming has a bipartite top-level structure: Edit, Read. DCS shares that structure, but both stages have meaningful structure that experienced EROL programmers discover by trial-and-error.
The core challenge in DCS programming is the explosion and dispersal of "program state". There is much more of it, and the programmer cannot access it directly. The bipartite model must gain structure:

.. table:: EROL and DCS :label:`eroldcstable`

   +-------------------------+------------------------------------------------+
   | EROL                    | DCS                                            |
   |=========================+================================================+
   | Edit                    | Scale out, then up in steps (SOUS)             |
   | Observe *program* state | Localize *problem* state for observation (LPS) |
   +-------------------------+------------------------------------------------+

Localizing Problem State
DCS coders learn informally to map symptoms to micro-techniques, then addressable root causes. Here is a partial record of one micro-technique, represented as a decision tree:

Does the message point to my code?
  1. Yes:
    Does the message make the mistake clear?
      3. Yes:
        DONE (switch to EROL coding)
      4. No:
        DONE (Convert the message to a filter, localize a sample of the distributed data, and switch to EROL coding.)
  2. No (it points to a crash in the distributed system itself):
    Is the system healthy?
      5. Yes (continue to next ?)
      6. No:
        restart it
    Did the message reveal that code was not properly distributed?
      7. Yes:
        DONE (redistribute the code)
      8. No (continue to next ?)
    Does the message convey where the system needs more resources?
      9. Yes:
        DONE (provide them)
      10. No:
        Can I process less data per run?
          11. Yes:
            DONE (reduce data load)
          12. No:
            DONE (buy more processing)

Scaling out, then up in steps
In distributed computing at scale, distribution per se is often a means to managing very large input, rather than a requirement in itself. The Run/evaluate stage of EROL/REPL coding thus involves two shifts:

  1) An atomic shift from executing on one machine to executing on many machines through an orchestration framework.
  2) A shift in input size of many orders of magnitude, which reveals threshold changes in behavior.

What was a black box (the engine executing code) becomes something of a grey box:

  1) An engine executing code locally on a (necessarily) small sample of the data (EROL).
  2) An engine distributing code for remote execution on the same sample used for EROL.
  3) An engine distributing code for remote execution on large subsets of the global data.
  4) An engine distributing code for remote execution on 100% of the global data.) An engine distributing code for remote execution on 100% of the global data.

Effective DCS coders therefore work in stages:

  1) EROL.
  2) Distribute the code and the sample that work locally, and see if distribution per se reveals a problem.
  3) Scale towards 100% of the data, watching for new problems of variance, allocation, or load.

Here are three error messages taken from the PySpark DCS framework, and how they flow through the decision tree:

  - "'NoneType' object has no attribute 'startswith'"
    + 1->3.
      * A trivial type conflict that any competent coder can handle.
      * A degenerate case homologous with EROL.
  - "ImportError: no module named my_local_utilities"
    + 2->7.
      * A code module was used locally but not distributed.
      * A simple application of SOUS returns the coder to EROL.
  - "org.apache.spark.SparkException: Kryo serialization failed: Buffer overflow."
    + 2->5->9. The system needs a particular configuration changed.

Discussion
----------
EROL coding has thrived for as long as we have had computers, despite its informal definition and transmission. It is simple and structurally parallel to the systems on which it is practiced. DCS presents coders with a novel and materially more complex structure. Coding communities have learned how to be productive despite the extra cognitive load, but each coder encountering DCS must do a great deal of work to develop usable mental models of the systems and the techniques necessary to manage them. Experience with a productive DCS community [MOZ2017]_ reveals coding procedures that are manageable in number, mappable to the structure of the underlying system, and expressible in regularized form.

Next steps
Testing the structure:

1) As an accurate representation of DCS coding procedures
2) As a knowledge transfer tool

Conclusion
----------


References
----------
.. [WIL1951] Maurice Wilkes *The Preparation of Programs for an Electronic Digital Computer*
           Addison-Wesley, 1951
.. [KR1999] B. Kernighan and R. Pike *The Practice of Programming*
           Addison-Wesley, 1999
.. [ASS1985] Harold Abelson, Gerald Jay Sussman, Julie Sussman *Structure and Interpretation of Computer Programs*
           MIT Press, 1985
.. [BEY2011]  Kurt W. Beyer, *Grace Hopper and the Invention of the Information Age*
           MIT Press, 2011
.. [MCC2004] Steve McConnell *Code Complete, 2nd Edition*
           Microsoft Press, 2004
.. [FOW1999] Martin Fowler *Refactoring*
           Addison-Wesley, 1999
.. [HOP1980] "Oral History of Captain Grace Hopper"
           http://archive.computerhistory.org/resources/text/Oral_History/Hopper_Grace/102702026.05.01.pdf
.. [MCC1962] John McCarthy *LISP 1.5 Programmer's Manual*
           MIT Press 1962
.. [SLF2013] Sherif Sakr, Anna Lui, Ayman G. Fayoumi "The Family of MapReduce and Large Scale Data Processing Systems"
           https://arxiv.org/pdf/1302.2966.pdf
.. [SPA2015] Michael Armbrust et al. "Spark SQL: Relational Data Processing in Spark"
           http://dl.acm.org/citation.cfm?id=2742797
.. [DAV2012] Thomas H. Davenport, Paul Barth and Randy Bean "How 'Big Data' Is Different"
           http://sloanreview.mit.edu/article/how-big-data-is-different/
.. [TUR1936] Alan Turing "On the Computable Numbers"
           Proceedings of the London mathematical society, 1936
.. [MOZ2017] Author discussion of DCS with colleagues, including presentation of preliminary versions of this materail to them.
.. [VON1945] John von Neumann, *First Draft of a Report on the EDVAC*
            United States Army, 1945
